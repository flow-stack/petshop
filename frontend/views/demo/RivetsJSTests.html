<!-- This template is a test for rivets.js on RivetsTestsController 
The controller initialization expects that this templates
follow the convention of being wrapped in one element.
The parent here is the element that is going to be bound -->
<section>
	<h1>What about controllers with two-way databind?</h1>
	<h2>enter rivets.js on flow</h2>

	<p>Sets the element's text content.</p>
	<h2 rv-text="model.name"></h2>

	<p>You can also bind text using interpolation.</p>
	<p>{ model.name } is { model.age } years old.</p>

	<p>Sets the element's text content.</p>
	<section rv-html="item.summary"></section>

	<p>Shows the element when the value evaluates to true and hides the element when the value evaluates to false.</p>
    <button rv-show="user.admin">Remove</button>

	<p>Hides the element when the value evaluates to true and shows the element when the value evaluates to false.</p>
	<section rv-hide="feature.disabled"></section>

	<p>Enables the element when the value evaluates to true and disables the element when the value evaluates to false.</p>
	<button rv-on-click="controller._onAha">Do you click?</button>

	<p>Disables the element when the value evaluates to true and enables the element when the value evaluates to false.</p>
	<button rv-on-click="controller._onMhm">Here?</button>

	<p>Inserts and binds the element as well as it's child nodes into the DOM when the value evaluates to true and removes / unbinds the element when the value evaluates to false.</p>
	<section rv-if="item.editable"></section>

	<p>Removes and ubinds the element as well as it's child nodes when the value evaluates to true and inserts / binds the element when the value evaluates to false.</p>
	<section rv-unless="item.locked"></section>

	<p>Sets the element's value when the attribute changes and sets the bound object's value when the input element changes from user input (two-way).</p>
	<input rv-value="model.name">
	<p>{ model.name }</p>

	<p>Checks the input when the value evaluates to true and unchecks the input when the value evaluates to false. This also sets the bound object's value to true/false when the user checks/unchecks the input (two-way).

Use this instead of value when binding to checkboxes or radio buttons.</p>
	<input type="checkbox" rv-checked="item.enabled">

	<p>Unchecks the input when the value evaluates to true and checks the input when the value evaluates to false. This also sets the bound object's value to false/true when the user checks/unchecks the input (two-way).

Use this instead of value when binding to checkboxes or radio buttons.</p>
	<input type="checkbox" rv-unchecked="item.disabled">

	<p>Binds an event listener on the element using the event specified in [event] and the bound object (should return a function) as the callback.

If the end value of the binding changes to a different function, this binder will automatically unbind the old callback and bind a new listener to the new function.</p>
	<button rv-on-click="item.destroy">Remove</button>

	<p>Appends a new instance of the element in place for each item in an array. Each element is bound with a completely new nested view that contains an additional property (named whatever value is in place of [item]) which points to the current iterated item in the array.

Also note that you may bind to the iterated item directly on the parent element which contains the actual rv-each declaration.</p>
	<ul>
		<li rv-each-todo="todos">
			<input type="checkbox" rv-checked="todo.done"> { todo.name }
		</li>
	<ul>

	<p>Adds a class (whatever value is in place of [classname]) on the element when the value evaluates to true and removes that class if the value evaluates to false.</p>
	<li rv-class-completed="todo.done">{ todo.name }</li>


	<p>Sets the value of an attribute (whatever value is in place of [attribute]) on the element.

If your binding declaration does not match any of the above routines, it will fallback to use this binding.</p>
	<input type="text" rv-placeholder="field.placeholder">

</section>

